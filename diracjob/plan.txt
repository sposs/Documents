Definitons:

Job : successions of steps, job has one Inputdata/inputsandbox and one Outputdata/outputsandbox. Each one can be a list 
of items 

2 types of jobs: user and production
user job: no control on inputdata and input sandbox. Just return error if files are not found
no control on steps applied: up to the user
control application existence
allow output file name setting
control site
control system config
control CPU needed
allow sb files as lfn or local files

production jobs: input data is to be controlled as FC query, input sandbox is for the steering files only
output data must be specified properly using well defined conventions
steps must be very well predefined: order is important e.g. register data cannot be done before end of job
control applications
control every step of the definition

Model:
          Class job 
class userJob  Class productionjob

                    Class Application 
cls Whizard   class mokka    class slic    class Marlin   class lcsim   class slicpandora   class ...


=======================================================================
class job(list):
setCPUtime
setsystemconfig
setname
setjobgroup
setdestination
setbannedsites
append(application): Define workflow parameters (get them from application) and set values 
Calls application.checkConsitency
Calls __addParameter
Sets default logfile if not set already
setignoreapplicationerrors

========================
class userjob(job):
setinputdata
setinputsandbox
setoutputdata
setoutputsandbox

========================
class productionjob(job):
setinputdataquery -> get energy, evttype, etc.
overload append(application): check consistency, for every step ask confirmation
get from application the elements to build path (self.prodparameters)
setproddetail
createProd
finalizeProd

===================================================================
class application:
self.name=''
self.version=''
self.prodparameters = {}
self.parameters (dict[name]['type']=type, [name]['description']=description, [name]['default']=default, etc.)
self.detectortype= None
self.datatype = None
self.nbevts = 0
self.energy = ''
self.logfile = ''
self.steeringfile = ''
self.OutputFile = ''
self.modulename = "ApplicationScript"

setname() (self.name)
setversion() (self.version)
setsteeringfile(file) (default none) (self.steeringfile)
setlogfile() (self.logfile): default is self.appname_self.appversion_stepid.log, created when appending to job
setNbEvts() (self.nbevts)
setEnergy() (self.energy)
setScript(): Generic application definition: to be used with ApplicationScript module

setoutputfile(file) (default none) (self.OutputFile):
if self.detectortype:
  self.prodparameters[file]["detectortype"]=self.detectortype
if self.datatype:
  self.prodparameters[file]["Datatype"]=self.datatype

getParameters() needed by Job
checkConsistency(): overloaded by every subclass to check validity (app version exists, links between apps !!!), 
check datatype

=======
class whizard(application):
setprocess: check process and find corresponding version
setlumi (optional)
setModel() default 'sm' list to obtain from ILCDIRAC.Core.Utilities.GeneratorModels getModels
self.appname="whizard"
self.modulename= "WhizardAnalysis"
self.datatype = 'gen'

=======
class stdhepcut(application):
setcutfile()
self.appname="stdhepcut"
self.modulename = "StdhepCut"
setnbevtsperfile()
self.datatype = 'gen'

=======
class overlayinput(application):
self.appname = 'overlay'
self.appversion='default' (no need in fact)
setDetectorModel() ("ILD" or "SID")
setBX() (int)
setGGhadInts() (float)
setProdID() (optional, int)
No outputfile

=======
class mokka(application):
self.detectortype='ILD'
self.appname="mokka"
self.modulename = "MokkaAnalysis"
setdetectormodel(sql file)
self.datatype = 'SIM'

=======
class marlin(application):
self.appname="marlin"
self.modulename = "MarlinAnalysis"
setgearfile (optionnal), but checkconsistency checks that Mokka ran before
self.datatype=None
setOutputDST(file) : 
self.prodparameters[file]['Datatype']="DST"
self.prodparameters[file]["detectortype"]='ILD'
setOutputREC(file) : 
self.prodparameters[file]['Datatype']="REC"
self.prodparameters[file]["detectortype"]='ILD'

=======
class slic(application):
self.detectortype= 'SID'
self.datatype = 'SIM'
self.appname='slic'
self.modulename = "SLICAnalysis"
setdetectormodel(zip name)

=======
class lcsim(application):
self.detectortype='SID'
self.datatype = None
self.appname='lcsim'
self.modulename = "LCSIMAnalysis"
setdetectormodel (optionnal), but checkConsistency checks that slic ran before
setOutputDST(file) : 
self.prodparameters[file]['Datatype']="DST"
self.prodparameters[file]["detectortype"]='SID'
setOutputREC(file) : 
self.prodparameters[file]['Datatype']="REC"
self.prodparameters[file]["detectortype"]='SID'

=======
class slicpandora(application):
self.detectortype='SID'
self.datatype='SIM'
self.appname='slicpandora'
self.modulename = "SlicPandoraAnalysis"
setpandorasettings (optionnal)

=======
class rootExec(application):
self.modulename = "RootExecutable" (or whatever)
self.appname='root'
setExec
setArgs

=======
class rootScript(application):
self.appname='root'
self.modulename = "RootScript" (or whatever)
setScript
setArgs

