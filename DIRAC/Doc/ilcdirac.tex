\documentclass[a4paper,12pt]{article}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes}

\usepackage[english]{babel}
\usepackage{courier}


\usepackage[T1]{fontenc}

\usepackage[pdftex, colorlinks=true]{hyperref}

\usepackage{listings}
\lstloadlanguages{python}
\title{ILC DIRAC, a grid solution for the LC community}
\author{S.~Poss}

\begin{document}
\tikzstyle{decision} = [diamond, draw, text badly centered, node distance=2.8cm]
\tikzstyle{block} = [rectangle, draw, text centered, rounded corners, node distance=2.2cm]
\tikzstyle{autoblock} = [rectangle, draw, text centered, rounded corners, node distance=2.2cm]
\tikzstyle{line} = [draw, -triangle 90]
\tikzstyle{dline} = [draw, dashed, -triangle 90]

\maketitle
\abstract{This document presents the different parts of the ILCDIRAC framework.
It is not intended as a manual, but as a support for the maintainer. It shows
the different elements, and details the corresponding code. It is clear that
this document will also show usage of the different bits, but not thoroughly.}

\tableofcontents

\section{Setups}
ILCDIRAC makes use of 2 setups:
\begin{itemize}
  \item ILC-Production: Main setup, production and user activity uses that
  setup. Running on volcd01.cern.ch (most services/agents, web server),
  volcd02.cern.ch (FileCatalogDB (not the service), overlay system), volcd03.cern.ch (LogSE)
  \item ILC-Developement: Used for testing new functionnality and new DIRAC
  releases. Runs on volcd03.cern.ch
\end{itemize}

\section{General structure}
The ILCDIRAC framework has the following structure:
\begin{itemize}
  \item Core: ILCDIRAC utilities used throughout the code, Sec.~\ref{core}
  \begin{itemize}
    \item script: ILCDIRAC specific scripts, detailed later
    \item Utilitites: Set of utilities used in the Workflow modules, and
    detailed later, Sec.~\ref{coreutilities}
  \end{itemize}
  \item Interfaces: Interface to DIRAC (and ILCDIRAC by
  extension) Sec.~\ref{interface}
  \begin{itemize}
    \item API: as it's name suggests
    \begin{itemize}
      \item NewInterface
      \begin{itemize}
        \item Examples: how to use the new interface
        \item Code for the new interface, detailed later, Sec.~\ref{application}
        and Sec.~\ref{job}
      \end{itemize}
      \item Examples
      \item and the old API code not maintained, but kept for backward
      compatibilty, except the \emph{DiracILC} code, still to be used.
      Sec.~\ref{diracilc}
    \end{itemize}
    \item scripts: Set of scripts using the ILCDIRAC interface, detailed later.
    Some are obsolete or not maintained. Sec.~\ref{interfacescripts}
  \end{itemize}
  \item OverlaySystem: Control the behavior of the overlay jobs, prevents
  killing the SRM. Sec.~\ref{overlaysys}
  \begin{itemize}
    \item Agent: Agent running on volcd03, resets the counters per site. Details
    below
    \item Client: Client to connect to the Overlay Service, exposes the
    functionnality of the server
    \item DB: Database definition. Schema is shown later
    \item Service: Service runnign on volcd03: essentially stores how many jobs
    are downloading the overlay files at a given site, and prevents a job from
    running in case there are too many. Code details are below.
  \end{itemize}
  \item ProcessProductionSystem (Sec.~\ref{processprodsys}): As of \today\
  still being developed. Aim is to have a service that handles the production to reduce the amount of human work:
  deploy applications, remove them, store relation between software and
  production, between data and productions, production details\ldots
  \begin{itemize}
    \item Agent: Agents running on one of the VO boxes (only in dev setup for
    the moment)
    \begin{itemize}
      \item DataRecoveryAgent: Recover failed jobs that did not report the File
      status, typically when pilots are killed.
      \item ProductionSummaryAgent: Collect the statistics for each production,
      produce nicely formatted web page containing also the production details
      \item SoftwareManagementAgent: Install/remove software from all sites,
      update availability
    \end{itemize}
    \item Client: Client for ProcessProductionHandler (service)
    \item DB: Database holding all the info for this service, detailed later
    \item Service: As name suggested serves the DB mostly.
    \item Utilities: Specific module for software management, details later
  \end{itemize}
  \item SoftwareManagement: Obsolete, as the functionnality was moved to
  ProcessProductionSystem, kept here for completeness. Not detailed
  \item Workflow: What runs on the grid
  \begin{itemize}
    \item Modules: they are completely detailed later, Sec.~\ref{modules}
  \end{itemize}
\end{itemize}


\section{Interface}\label{interface}
Here we detail the content of every class in this package. The Examples are
treated separately, as theyu only use the functionnality exposed here. The order
is as follows: the job and application classes are presented then the DiracILC
class. The old API is not presented as not maintained, and will be dropped in one of the future
releases.

\subsection{General considerations}
When reviewing the Interface, the motivation was to render ther whole system
easier to use and to maintain. The first idea is to separate the job and the
applications that should run in the job. The reason is that it allows for a
better flexibility, namely a user can predefine a set of applications,
independantly of the job they run in.

In Fig.~\ref{fig:defdefinejob} the usual process of defining a job is shown. 
\begin{figure}[h]
\begin{center}
\begin{tikzpicture}[scale=0.8,auto]
\matrix [column sep=7mm, row sep=4mm,ampersand replacement=\&]
{
\node [block] (app1) {Define Application 1};\\
\node [block] (app2) {Define Application 2};\\
\node [block] (job) {Define Job};\\
\node [block] (submit) {Submit job};\\
};
\path [line] (app1) -- (app2);
\path [line] (app2) -- (job);
\path [line] (job) -- (submit);
\end{tikzpicture}
\end{center}
\caption{Usual process of job definition}
\label{fig:defdefinejob}
\end{figure}
In the ILCDIRAC framework, this process is modified to separate the applications
and the job, as shown in Fig.~\ref{fig:definejob}.
\begin{figure}[h]
\begin{center}
\begin{tikzpicture}[scale=0.8,auto]
\matrix [column sep=7mm, row sep=4mm,ampersand replacement=\&]
{
\node {App definition};\&
\node {Job definition};\\
\node [block] (app1) {Application 1};\&
\node [block] (job) {Define Job};\\

\node [block] (app2) {Application 2};\&
~\\
~\&
\node [block] (submit) {Submit job};\\
};
\path [line] (app1) -- (job);
\path [line] (app2) -- (job);
\path [line] (job) -- (submit);
\end{tikzpicture}
\end{center}
\caption{ILCDIRAC process of job definition. The arrows between application and
job stand for job.append(application). This is
technically explained later.}
\label{fig:definejob}
\end{figure}

The applications are ran on the GRID using the DIRAC workflow system. This is
briefly explained in Sec.~\ref{workflowsys}.

\subsection{Application}\label{application}
This class is the base application class, all applications must inherit from
this. 

The general principle in the application class comes from the fact that all
applications that runs on the grid share a set of parameters. Those are:
\begin{itemize}
  \item \emph{Application name}: Name of the application, e.g. marlin, SLIC,
  lcio, etc.
  \item \emph{Application version}: As most software uses versionning with e.g.
  SVN, there are different versions that correspond to a set of functionnality. When
  willing to run several versions of the software in parallel, this is needed.
  \item \emph{Options (or steering) file}: All application need to be told what
  they need to do. 
  \item \emph{Input file (or none)}: Most application used in HEP are designed
  to transform a set of data into another. Physics generators are an exception as
  they only produce files.
  \item \emph{Output file}: All applications produce something: binary data,
  text files, logs, etc. Those should be handled.
  \item \emph{Log file}: To debug, it's needed to keep the stdout of the
  application.
\end{itemize}
As this was designed in the context of ILCDIRAC, there are several other
parameters that are shared between the applications:
\begin{itemize}
  \item \emph{Number of events}: The number of events that will be ran by the
  application. Depending on the application, this can be omitted.
  \item \emph{Energy}: The sample's energy. Can be needed to determine which
  calibration to use, or, in ILC's case, the overlay files to use.
\end{itemize}
There are other common functionnality that will be detailed later as they are
use-specific.


\subsubsection{GenericApplication}\label{genericapp}
This application is intended to run a script based on an application. 

\subsubsection{GetSRMFile}\label{getsrmfile}
When a file is not in the File Catalog, it can still be access using this
application.

\subsubsection{RootScript}\label{rootscript}
Run a ROOT based script, shell or python.

\subsubsection{RootMacro}\label{rootmacro}
Run a ROOT macro (.C).

\subsubsection{Whizard}\label{whizard}
Generate events using Whizard.

\subsubsection{Pythia}\label{pythia}
Generate events using PYTHIA standalone.

\subsubsection{PostGenSelection}\label{postgensel}
This utility was created for JJ Blaising, but not used anymore.

\subsubsection{StdhepCut}\label{stdhepcut}
Used to apply generator level cuts on the final stdhep files. Application code
written by Lars Weuste, extended by John Marshall and Astrid Munnich. 

\subsubsection{StdHepSplit}\label{stdhepsplit}
Cut a stdhep file in chunks. Mostly used for the SID production

\subsubsection{Mokka}\label{mokka}
Run Mokka: ILD simulation

\subsubsection{SLIC}\label{slic}
Run SLIC: SiD simulation

\subsubsection{OverlayInput}\label{overlay}
Download the files for the overlay.

\subsubsection{Marlin}\label{marlin}
Run Marlin: reconstruction for ILD

\subsubsection{LCSIM}\label{lcsim}
Run LCSIM: Reconstruction for SiD

\subsubsection{SLICPandora}\label{slicpan}
Apply Pandora PFO on SiD reconstructed data

\subsubsection{CheckCollections}\label{checkcoll}
Make sure a set of collection is available in the input file.

\subsubsection{SLCIOConcatenate}\label{slcioconcat}
Concatenate many slcio files into one. Useful for the ``Merge'' jobs. 

\subsubsection{SLCIOSplit}\label{slciosplit}
Split a slcio file into many chunks. 

\subsubsection{Tomato}\label{tomato}
Run the Tomato analysis on an input file.

\subsection{Job}\label{job}
This class is the base Job class, all job types must inherit from this class.

\subsubsection{UserJob}\label{userjob}
User job class for user jobs\ldots

\subsubsection{ProductionJob}\label{prodjob}
Production job class. The main different with the previous job class is the fact
that it's not intended to be submitted to Dirac, but only to the
TransformationSysten.

\subsubsection{SIDProductionJob}\label{sidprod}
SIDProductionJob. Same as the previous class, but implementing SiD production
specific functionnality.

\subsection{DiracILC}\label{diracilc}
This class is the interface between the Job and DIRAC.

\subsection{scripts}\label{interfacescripts}
Several scripts are developed to provide specific funtionnality for ILCDIRAC.

\section{Workflow Modules}\label{modules}
The following are the modules running on the grid, executing the different
applications.

\section{Core}\label{core}
Core functionnality.
\subsection{Utilities}\label{coreutilities}
The following utilities are used to provide specific functions.
\subsection{scripts}\label{corescripts}
The scripts\ldots

\section{Overlay System}\label{overlaysys}
Make sure the jobs don't kill the disks.

\section{Process Production System}\label{processprodsys}
Big service\ldots

\section{Making releases}\label{makingrelease}
Here we detail the manner to create a release.

\section{Workflow mechanism}\label{workflowsys}
\end{document}